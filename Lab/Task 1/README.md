## Task 1 - Generate a key pair, encrypt/decrypt/sign data.
![By Software:OpenSSL contributorsScreenshot:VulcanSphere - Self-taken; derivative work, Public Domain, https://commons.wikimedia.org/w/index.php?curid=125198571](UEFI_Secure_Boot_DB_certificate.png) 

This first task will illustrate the basics of using OpenSSL to generate a public-private key pair. [OpenSSL](https://en.wikipedia.org/wiki/OpenSSL) is an open source cryptographic toolkit that facilitates secure communications between endpoints on a network. It is widely used by Internet servers, including the majority of HTTPS websites. 

### Goals
- Understand the process of creating a public-private key pair using OpenSSL
- Understand how to interpret some of the contents inside public-private keys
- Be able to manipulate public-private keys using the CLI
- Encode and sign data using public-private keys


### Instructions
0. Ensure you are in the [Task 1 directory](.) by using `cd` or your OS' equivalent command to navigate there. 
1. Start by generating a Private Key with the following command:

    ```openssl genrsa -out private.key 2048```

    This will generate a private key in the current directory by using the [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) algorithm - a relatively slow algorithm that relies on prime number factorisation for security. 

    Note that the two provided arguments above refer to the filename of the private key, and the key length measured in bits - namely, 2048 bits. More bits means more resiliency against attacks!

2. Inspect the private key by executing 
    ```cat private.key```.


3. Even though the format of the file is text, the actual contents are not very sensible - we can use the following command to extract the information in a manner that is human readable:
```openssl rsa -text -in private.key -noout```

    What do you think these contents represent?

    <details> 
    <summary>Knowledge checkpoint</summary>
    These are the mathematical parameters used in the creation of the private key, stored in hexadecimal format. As mentioned, RSA uses prime numbers to generate private keys - you can notice terms related to number theory, such as modulus or exponent. More importantly, first prime and second prime indicate the prime numbers used in generating the private key - if these are leaked, then the security of the private key has been compromised. If you're interested in learning more, you can refer to the formal RSA RFC <a href=https://www.rfc-editor.org/rfc/rfc3447#appendix-A.1.1>here</a>
    </details>


4. As mentioned during the lecture, public and private keys come in pairs. You can extract the public key from the private key that was just generated by running
    ```openssl rsa -in private.key -pubout -out public.key```

5. Again, let's inspect the decoded contents of the public key:
    ```openssl rsa -text -pubin -in public.key -noout```

    What do you observe?
        <details> 
        <summary>Knowledge checkpoint</summary>
        The mathematical parameters in the decoded public key are a subset of the parameters of the private key, in particular the modulus and exponent. The basis of RSA is that of a one-way (trapdoor) function: Given the modulus and exponent, it is impossible to determine the other parameters present in the private key, such as the prime numbers. But given the prime numbers, it is trivial to calculate the modulus and exponent.
        </details>

6. Now, let's do something a bit more useful with these keys - namely, encrypt some information, and then decrypt it.
    1. Start by editing the file [here](./message_to_be_encrypted.txt). Replace the contents with something else.
    2. Using the public key that was created earlier, encrypt the file above with the command ```openssl pkeyutl -encrypt -inkey public.key -pubin -in message_to_be_encrypted.txt -out encrypted_file.bin```
    This will produce a binary file as the output, containing the original message encrypted with the public key.
    3. Verify that the message is indeed encrypted by running any of the following commands, depending on your OS:
    - `cat encrypted_file.bin`
    - `xxd -b encrypted_file.bin`
    - `hexdump -C encrypted_file.bin`
    4. Decrypt the file with your private key: ```openssl pkeyutl -decrypt -inkey private.key -in encrypted_file.bin -out decrypted_file.txt```
    5. Inspect the contents - they should match the original message. 

7. As mentioned, private and public key allow entities to verify their identity through signing. As a minimal example, an entity can sign a piece of data with its private key, and then any party can use the entity's public key to verify the signature. To put this to practice:
    1. Run ```openssl dgst -sha256 -sign private.key -out /tmp/sign.sha256 message_to_be_encrypted.txt``` to sign the message modified earlier with your private key.
    2. You'll notice that the output of the file is binary. The default output format of the OpenSSL signature is binary. When transmitting data over the internet, it is good practice to compress it; however, as we will verify the signature locally, we won't worry about that for now.
    3. Run ```openssl dgst -sha256 -verify public.key -signature /tmp/sign.sha256 message_to_be_encrypted.txt``` to verify the signed message against the original message, by using the public key.
    4. Try changing the signed message, by removing a few characters from the middle of the file; then, running the verification command as per step 3. As an example: ```vim /tmp/sign.sha256```.  
    
    What do you think will happen when you try to verify the signature?
        <details> 
        <summary>Knowledge checkpoint</summary>
        Modifying the signed message causes the signature verification to fail - this shows that signing not only ensures authenticity, but also data integrity.  
        </details>